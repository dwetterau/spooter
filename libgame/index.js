// Generated by CoffeeScript 1.9.2
(function() {
  var BULLET_MIN_SIZE, BULLET_SIZE_FACTOR, BULLET_SPEED, ENEMY_ACCELERATION_LIMIT, ENEMY_MIN_SIZE, ENEMY_SHOOT_PERCENTAGE, ENEMY_SHRINKAGE, ENEMY_SIZE_RANGE, ENEMY_SPAWN_PERCENTAGE, ENEMY_SPEED_LIMIT, ENEMY_VISION_DIST, Game, LOOP_TIME_INTERVAL, MAX_ENEMIES, MIN_ENEMIES, PLAYER_ACCELERATION_LIMIT, PLAYER_SPEED_LIMIT,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  LOOP_TIME_INTERVAL = 10;

  BULLET_SPEED = 500;

  PLAYER_SPEED_LIMIT = 200;

  PLAYER_ACCELERATION_LIMIT = 200;

  MIN_ENEMIES = 15;

  MAX_ENEMIES = 50;

  ENEMY_SPAWN_PERCENTAGE = .001;

  ENEMY_SHRINKAGE = 5;

  ENEMY_SIZE_RANGE = 40;

  ENEMY_MIN_SIZE = 20;

  ENEMY_SPEED_LIMIT = 120;

  ENEMY_ACCELERATION_LIMIT = 100;

  ENEMY_VISION_DIST = 250;

  ENEMY_SHOOT_PERCENTAGE = .01;

  BULLET_MIN_SIZE = 5;

  BULLET_SIZE_FACTOR = .2;

  Game = (function() {
    function Game() {
      this.loop = bind(this.loop, this);
      this.doPhysics = bind(this.doPhysics, this);
      this.moveEnemy = bind(this.moveEnemy, this);
      this.enemyAI = bind(this.enemyAI, this);
      this.shrinkEnemy = bind(this.shrinkEnemy, this);
      this.movePlayer = bind(this.movePlayer, this);
      this.moveEntity = bind(this.moveEntity, this);
      this.broadcastState = bind(this.broadcastState, this);
      this.deletePlayer = bind(this.deletePlayer, this);
      this.createEnemy = bind(this.createEnemy, this);
      this.createBullet = bind(this.createBullet, this);
      this.handleShoot = bind(this.handleShoot, this);
      this.handleMove = bind(this.handleMove, this);
      this.worldWidth = 2000;
      this.worldHeight = 2000;
      this.players = {};
      this.nextPlayerId = 0;
      this.enemies = {};
      this.nextEnemyId = 0;
      this.bullets = {};
      this.nextBulletId = 0;
      this.io = null;
    }

    Game.prototype.start = function(io) {
      console.log("Game server started!");
      this.io = io;
      io.on('connection', (function(_this) {
        return function(socket) {
          return _this.initializeConnection(socket);
        };
      })(this));
      return this.loop();
    };

    Game.prototype.initializeConnection = function(socket) {
      var newPlayerId;
      newPlayerId = this.nextPlayerId++;
      this.createPlayer(newPlayerId);
      socket.on("move", this.handleMove);
      socket.on("shoot", this.handleShoot);
      socket.on("disconnect", (function(_this) {
        return function() {
          console.log("Player disconnected!", newPlayerId);
          return _this.deletePlayer(newPlayerId);
        };
      })(this));
      return socket.emit('initialize', {
        playerId: newPlayerId
      });
    };

    Game.prototype.handleMove = function(message) {
      var mouseX, mouseY, player, playerId;
      if ((message == null) || (message.playerId == null)) {
        return;
      }
      mouseX = message.mouseX, mouseY = message.mouseY, playerId = message.playerId;
      if ((mouseX == null) || (mouseY == null) || !(playerId in this.players)) {
        return;
      }
      player = this.players[playerId];
      player.ax = mouseX - player.x;
      return player.ay = mouseY - player.y;
    };

    Game.prototype.handleShoot = function(message) {
      var p, playerId, vx, vy, x, y;
      if ((message == null) || (message.playerId == null)) {
        return;
      }
      playerId = message.playerId;
      if (!(playerId in this.players)) {
        return;
      }
      p = this.players[playerId];
      x = p.x, y = p.y;
      vx = p.ax;
      vy = p.ay;
      return this.createBullet(x, y, vx, vy, p.type, p.r);
    };

    Game.prototype.createPlayer = function(playerId) {
      var x, y;
      x = Math.random() * this.worldWidth;
      y = Math.random() * this.worldHeight;
      return this.players[playerId] = {
        type: 'player',
        id: playerId,
        r: 20,
        x: x,
        y: y,
        vx: 0,
        vy: 0,
        ax: 0,
        ay: 0
      };
    };

    Game.prototype.createBullet = function(x, y, vx, vy, ownerType, ownerR) {
      var id, mag, r;
      id = this.nextBulletId++;
      mag = Math.sqrt(vx * vx + vy * vy);
      if (mag === 0) {
        return;
      }
      vx *= BULLET_SPEED / mag;
      vy *= BULLET_SPEED / mag;
      r = Math.max(BULLET_MIN_SIZE, Math.round(ownerR * BULLET_SIZE_FACTOR));
      return this.bullets[id] = {
        type: 'bullet',
        id: id,
        r: r,
        x: x,
        y: y,
        vx: vx,
        vy: vy,
        ownerType: ownerType
      };
    };

    Game.prototype.createEnemy = function() {
      var id, r, vx, vy, x, y;
      r = parseInt(Math.random() * ENEMY_SIZE_RANGE) + ENEMY_MIN_SIZE;
      x = r + Math.random() * (this.worldWidth - 2 * r);
      y = r + Math.random() * (this.worldHeight - 2 * r);
      vx = 0;
      vy = 0;
      id = this.nextEnemyId++;
      return this.enemies[id] = {
        type: 'enemy',
        id: id,
        r: r,
        x: x,
        y: y,
        vx: vx,
        vy: vy
      };
    };

    Game.prototype.deletePlayer = function(playerId) {
      if (playerId in this.players) {
        return delete this.players[playerId];
      }
    };

    Game.prototype.broadcastState = function() {
      var bullet, enemy, entities, id, player, ref, ref1, ref2, state;
      entities = [];
      ref = this.bullets;
      for (id in ref) {
        bullet = ref[id];
        entities.push(bullet);
      }
      ref1 = this.enemies;
      for (id in ref1) {
        enemy = ref1[id];
        entities.push(enemy);
      }
      ref2 = this.players;
      for (id in ref2) {
        player = ref2[id];
        entities.push(player);
      }
      state = {
        worldWidth: this.worldWidth,
        worldHeight: this.worldHeight,
        entities: entities
      };
      return this.io.sockets.emit('state', state);
    };

    Game.prototype.moveEntity = function(entity, dt, ax, ay, speedLimit) {
      var clampedX, clampedY, speed;
      entity.vx += dt * ax;
      entity.vy += dt * ay;
      speed = Math.sqrt(entity.vx * entity.vx + entity.vy * entity.vy);
      if (speed > speedLimit) {
        entity.vx *= speedLimit / speed;
        entity.vy *= speedLimit / speed;
      }
      entity.x += dt * entity.vx;
      entity.y += dt * entity.vy;
      clampedX = false;
      clampedY = false;
      if (entity.x - entity.r < 0) {
        clampedX = true;
        entity.x = entity.r;
      }
      if (entity.x + entity.r > this.worldWidth) {
        clampedX = true;
        entity.x = this.worldWidth - entity.r;
      }
      if (entity.y - entity.r < 0) {
        clampedY = true;
        entity.y = entity.r;
      }
      if (entity.y + entity.r > this.worldHeight) {
        clampedY = true;
        entity.y = this.worldHeight - entity.r;
      }
      if (clampedX) {
        entity.vx = 0;
      }
      if (clampedY) {
        return entity.vy = 0;
      }
    };

    Game.prototype.movePlayer = function(player, dt) {
      var mag;
      mag = Math.sqrt(player.ax * player.ax + player.ay * player.ay);
      if (mag > PLAYER_ACCELERATION_LIMIT) {
        player.ax *= PLAYER_ACCELERATION_LIMIT / mag;
        player.ay *= PLAYER_ACCELERATION_LIMIT / mag;
      }
      return this.moveEntity(player, dt, player.ax, player.ay, PLAYER_SPEED_LIMIT);
    };

    Game.prototype.moveBullet = function(bullet, dt) {
      bullet.x += dt * bullet.vx;
      bullet.y += dt * bullet.vy;
      if (bullet.x - bullet.r < 0) {
        return true;
      }
      if (bullet.x + bullet.r > this.worldWidth) {
        return true;
      }
      if (bullet.y - bullet.r < 0) {
        return true;
      }
      if (bullet.y + bullet.r > this.worldHeight) {
        return true;
      }
      return false;
    };

    Game.prototype.collides = function(e1, e2) {
      var dr, dx, dy;
      dx = e1.x - e2.x;
      dy = e1.y - e2.y;
      dr = e1.r + e2.r;
      return dx * dx + dy * dy <= dr * dr;
    };

    Game.prototype.shrinkEnemy = function(enemy) {
      enemy.r -= ENEMY_SHRINKAGE;
      return enemy.r < ENEMY_MIN_SIZE;
    };

    Game.prototype.enemyAI = function(enemy) {
      var ax, ay, closestDistance, closestPlayer, dist, dx, dy, pid, player, ref, vmag, x, y;
      if (enemy.destination) {
        vmag = enemy.vx * enemy.vx + enemy.vy * enemy.vy;
        dx = enemy.x - enemy.destination.x;
        dy = enemy.y - enemy.destination.y;
        if (vmag > dx * dx + dy * dy) {
          enemy.destination = void 0;
        }
      }
      closestPlayer = void 0;
      closestDistance = 100000000;
      ref = this.players;
      for (pid in ref) {
        player = ref[pid];
        dx = enemy.x - player.x;
        dy = enemy.y - player.y;
        dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < closestDistance) {
          closestDistance = dist;
          closestPlayer = player;
        }
      }
      if (!enemy.destination && closestDistance > ENEMY_VISION_DIST) {
        x = Math.random() * this.worldWidth;
        y = Math.random() * this.worldHeight;
        enemy.destination = {
          x: x,
          y: y
        };
      }
      if (closestDistance < ENEMY_VISION_DIST) {
        enemy.destination = {
          x: closestPlayer.x,
          y: closestPlayer.y
        };
        if (Math.random() < ENEMY_SHOOT_PERCENTAGE) {
          ax = closestPlayer.x - enemy.x;
          ay = closestPlayer.y - enemy.y;
          this.createBullet(enemy.x, enemy.y, ax, ay, enemy.type, enemy.r);
          return console.log("enemy shooting");
        }
      }
    };

    Game.prototype.moveEnemy = function(enemy, dt) {
      var ax, ay, mag;
      if (!enemy.destination) {
        return;
      }
      ax = enemy.destination.x - enemy.x;
      ay = enemy.destination.y - enemy.y;
      mag = Math.sqrt(ax * ax + ay * ay);
      if (mag > ENEMY_ACCELERATION_LIMIT) {
        ax *= ENEMY_ACCELERATION_LIMIT / mag;
        ay *= ENEMY_ACCELERATION_LIMIT / mag;
      }
      return this.moveEntity(enemy, dt, ax, ay, ENEMY_SPEED_LIMIT);
    };

    Game.prototype.doPhysics = function(dt) {
      var bullet, bulletsToRemove, eid, enemiesToDelete, enemy, i, id, j, len, len1, pid, player, ref, ref1, ref2, ref3, ref4, results;
      for (id in this.players) {
        this.movePlayer(this.players[id], dt);
      }
      bulletsToRemove = [];
      for (id in this.bullets) {
        if (this.moveBullet(this.bullets[id], dt)) {
          bulletsToRemove.push(id);
        }
      }
      for (i = 0, len = bulletsToRemove.length; i < len; i++) {
        id = bulletsToRemove[i];
        delete this.bullets[id];
      }
      enemiesToDelete = [];
      ref = this.bullets;
      for (id in ref) {
        bullet = ref[id];
        if (bullet.ownerType === 'player') {
          ref1 = this.enemies;
          for (eid in ref1) {
            enemy = ref1[eid];
            if (eid in enemiesToDelete) {
              continue;
            }
            if (this.collides(enemy, bullet)) {
              bulletsToRemove.push(id);
              if (this.shrinkEnemy(enemy)) {
                enemiesToDelete[eid] = true;
              }
            }
          }
        } else if (bullet.ownerType === 'enemy') {
          ref2 = this.players;
          for (pid in ref2) {
            player = ref2[pid];
            if (this.collides(player, bullet)) {
              console.log("player got hit by bullet from enemy");
            }
          }
        }
      }
      for (eid in enemiesToDelete) {
        delete this.enemies[eid];
      }
      for (j = 0, len1 = bulletsToRemove.length; j < len1; j++) {
        id = bulletsToRemove[j];
        delete this.bullets[id];
      }
      ref3 = this.enemies;
      for (id in ref3) {
        enemy = ref3[id];
        this.enemyAI(enemy);
      }
      ref4 = this.enemies;
      results = [];
      for (id in ref4) {
        enemy = ref4[id];
        results.push(this.moveEnemy(enemy, dt));
      }
      return results;
    };

    Game.prototype.loop = function() {
      var diff, numEnemies, startTime;
      startTime = new Date().getTime();
      numEnemies = Object.keys(this.enemies).length;
      if (Math.random() < ENEMY_SPAWN_PERCENTAGE || numEnemies < MIN_ENEMIES) {
        if (numEnemies < MAX_ENEMIES) {
          this.createEnemy();
        }
      }
      this.doPhysics(LOOP_TIME_INTERVAL / 1000.0);
      this.broadcastState();
      diff = LOOP_TIME_INTERVAL - ((new Date().getTime()) - startTime);
      if (diff < 0) {
        console.log("WARNING: Game loop computation too slow!");
        diff = 0;
      }
      return setTimeout(this.loop, diff);
    };

    return Game;

  })();

  module.exports = Game;

}).call(this);

//# sourceMappingURL=index.js.map
