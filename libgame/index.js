// Generated by CoffeeScript 1.8.0
(function() {
  var BULLET_SPEED, ENEMY_MIN_SIZE, ENEMY_SHRINKAGE, ENEMY_SIZE_RANGE, ENEMY_SPAWN_PERCENTAGE, Game, LOOP_TIME_INTERVAL, MAX_ENEMIES, MIN_ENEMIES, PLAYER_SPEED_LIMIT,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  LOOP_TIME_INTERVAL = 10;

  BULLET_SPEED = 500;

  PLAYER_SPEED_LIMIT = 300;

  MIN_ENEMIES = 15;

  MAX_ENEMIES = 100;

  ENEMY_SPAWN_PERCENTAGE = .05;

  ENEMY_SHRINKAGE = 5;

  ENEMY_SIZE_RANGE = 40;

  ENEMY_MIN_SIZE = 20;

  Game = (function() {
    function Game() {
      this.loop = __bind(this.loop, this);
      this.doPhysics = __bind(this.doPhysics, this);
      this.shrinkEnemy = __bind(this.shrinkEnemy, this);
      this.movePlayer = __bind(this.movePlayer, this);
      this.broadcastState = __bind(this.broadcastState, this);
      this.deletePlayer = __bind(this.deletePlayer, this);
      this.createEnemy = __bind(this.createEnemy, this);
      this.createBullet = __bind(this.createBullet, this);
      this.handleShoot = __bind(this.handleShoot, this);
      this.handleMove = __bind(this.handleMove, this);
      this.worldWidth = 2000;
      this.worldHeight = 2000;
      this.players = {};
      this.nextPlayerId = 0;
      this.enemies = {};
      this.nextEnemyId = 0;
      this.bullets = {};
      this.nextBulletId = 0;
      this.io = null;
    }

    Game.prototype.start = function(io) {
      console.log("Game server started!");
      this.io = io;
      io.on('connection', (function(_this) {
        return function(socket) {
          return _this.initializeConnection(socket);
        };
      })(this));
      return this.loop();
    };

    Game.prototype.initializeConnection = function(socket) {
      var newPlayerId;
      newPlayerId = this.nextPlayerId++;
      this.createPlayer(newPlayerId);
      socket.on("move", this.handleMove);
      socket.on("shoot", this.handleShoot);
      socket.on("disconnect", (function(_this) {
        return function() {
          console.log("Player disconnected!", newPlayerId);
          return _this.deletePlayer(newPlayerId);
        };
      })(this));
      return socket.emit('initialize', {
        playerId: newPlayerId
      });
    };

    Game.prototype.handleMove = function(message) {
      var mouseX, mouseY, player, playerId;
      if ((message == null) || (message.playerId == null)) {
        return;
      }
      mouseX = message.mouseX, mouseY = message.mouseY, playerId = message.playerId;
      if ((mouseX == null) || (mouseY == null) || !(playerId in this.players)) {
        return;
      }
      player = this.players[playerId];
      player.ax = mouseX - player.x;
      return player.ay = mouseY - player.y;
    };

    Game.prototype.handleShoot = function(message) {
      var p, playerId, vx, vy, x, y;
      if ((message == null) || (message.playerId == null)) {
        return;
      }
      playerId = message.playerId;
      if (!(playerId in this.players)) {
        return;
      }
      p = this.players[playerId];
      x = p.x, y = p.y;
      vx = p.ax;
      vy = p.ay;
      return this.createBullet(x, y, vx, vy, p.type);
    };

    Game.prototype.createPlayer = function(playerId) {
      var x, y;
      x = Math.random() * this.worldWidth;
      y = Math.random() * this.worldHeight;
      return this.players[playerId] = {
        type: 'player',
        id: playerId,
        r: 20,
        x: x,
        y: y,
        vx: 0,
        vy: 0,
        ax: 0,
        ay: 0
      };
    };

    Game.prototype.createBullet = function(x, y, vx, vy, type) {
      var id, mag;
      id = this.nextBulletId++;
      mag = Math.sqrt(vx * vx + vy * vy);
      if (mag === 0) {
        return;
      }
      vx *= BULLET_SPEED / mag;
      vy *= BULLET_SPEED / mag;
      return this.bullets[id] = {
        type: 'bullet',
        id: id,
        r: 5,
        x: x,
        y: y,
        vx: vx,
        vy: vy,
        ownerType: type
      };
    };

    Game.prototype.createEnemy = function() {
      var id, r, vx, vy, x, y;
      r = parseInt(Math.random() * ENEMY_SIZE_RANGE) + ENEMY_MIN_SIZE;
      x = r + Math.random() * (this.worldWidth - 2 * r);
      y = r + Math.random() * (this.worldHeight - 2 * r);
      vx = 0;
      vy = 0;
      id = this.nextEnemyId++;
      return this.enemies[id] = {
        type: 'enemy',
        id: id,
        r: r,
        x: x,
        y: y,
        vx: vx,
        vy: vy
      };
    };

    Game.prototype.deletePlayer = function(playerId) {
      if (playerId in this.players) {
        return delete this.players[playerId];
      }
    };

    Game.prototype.broadcastState = function() {
      var bullet, enemy, entities, id, player, state, _ref, _ref1, _ref2;
      entities = [];
      _ref = this.bullets;
      for (id in _ref) {
        bullet = _ref[id];
        entities.push(bullet);
      }
      _ref1 = this.enemies;
      for (id in _ref1) {
        enemy = _ref1[id];
        entities.push(enemy);
      }
      _ref2 = this.players;
      for (id in _ref2) {
        player = _ref2[id];
        entities.push(player);
      }
      state = {
        worldWidth: this.worldWidth,
        worldHeight: this.worldHeight,
        entities: entities
      };
      return this.io.sockets.emit('state', state);
    };

    Game.prototype.movePlayer = function(player, dt) {
      var clampedX, clampedY, speed;
      player.vx += dt * player.ax;
      player.vy += dt * player.ay;
      player.x += dt * player.vx;
      player.y += dt * player.vy;
      clampedX = false;
      clampedY = false;
      if (player.x - player.r < 0) {
        clampedX = true;
        player.x = player.r;
      }
      if (player.x + player.r > this.worldWidth) {
        clampedX = true;
        player.x = this.worldWidth - player.r;
      }
      if (player.y - player.r < 0) {
        clampedY = true;
        player.y = player.r;
      }
      if (player.y + player.r > this.worldHeight) {
        clampedY = true;
        player.y = this.worldHeight - player.r;
      }
      if (clampedX) {
        player.vx = 0;
      }
      if (clampedY) {
        player.vy = 0;
      }
      speed = Math.sqrt(player.vx * player.vx + player.vy * player.vy);
      if (speed > PLAYER_SPEED_LIMIT) {
        player.vx *= PLAYER_SPEED_LIMIT / speed;
        return player.vy *= PLAYER_SPEED_LIMIT / speed;
      }
    };

    Game.prototype.moveBullet = function(bullet, dt) {
      bullet.x += dt * bullet.vx;
      bullet.y += dt * bullet.vy;
      if (bullet.x - bullet.r < 0) {
        return true;
      }
      if (bullet.x + bullet.r > this.worldWidth) {
        return true;
      }
      if (bullet.y - bullet.r < 0) {
        return true;
      }
      if (bullet.y + bullet.r > this.worldHeight) {
        return true;
      }
      return false;
    };

    Game.prototype.collides = function(e1, e2) {
      var dr, dx, dy;
      dx = e1.x - e2.x;
      dy = e1.y - e2.y;
      dr = e1.r + e2.r;
      return dx * dx + dy * dy <= dr * dr;
    };

    Game.prototype.shrinkEnemy = function(enemy) {
      enemy.r -= ENEMY_SHRINKAGE;
      return enemy.r < ENEMY_MIN_SIZE;
    };

    Game.prototype.doPhysics = function(dt) {
      var bullet, bulletsToRemove, eid, enemiesToDelete, enemy, id, pid, player, _i, _j, _len, _len1, _ref, _ref1, _ref2, _results;
      for (id in this.players) {
        this.movePlayer(this.players[id], dt);
      }
      bulletsToRemove = [];
      for (id in this.bullets) {
        if (this.moveBullet(this.bullets[id], dt)) {
          bulletsToRemove.push(id);
        }
      }
      for (_i = 0, _len = bulletsToRemove.length; _i < _len; _i++) {
        id = bulletsToRemove[_i];
        delete this.bullets[id];
      }
      enemiesToDelete = [];
      _ref = this.bullets;
      for (id in _ref) {
        bullet = _ref[id];
        if (bullet.ownerType === 'player') {
          _ref1 = this.enemies;
          for (eid in _ref1) {
            enemy = _ref1[eid];
            if (eid in enemiesToDelete) {
              continue;
            }
            if (this.collides(enemy, bullet)) {
              bulletsToRemove.push(id);
              if (this.shrinkEnemy(enemy)) {
                enemiesToDelete[eid] = true;
              }
            }
          }
        } else if (bullet.ownerType === 'enemy') {
          _ref2 = this.players;
          for (pid in _ref2) {
            player = _ref2[pid];
            if (this.collides(player, bullet)) {
              console.log("player got hit by bullet from enemy");
            }
          }
        }
      }
      for (eid in enemiesToDelete) {
        delete this.enemies[eid];
      }
      _results = [];
      for (_j = 0, _len1 = bulletsToRemove.length; _j < _len1; _j++) {
        id = bulletsToRemove[_j];
        _results.push(delete this.bullets[id]);
      }
      return _results;
    };

    Game.prototype.loop = function() {
      var diff, numEnemies, startTime;
      startTime = new Date().getTime();
      numEnemies = Object.keys(this.enemies).length;
      if (Math.random() < ENEMY_SPAWN_PERCENTAGE || numEnemies < MIN_ENEMIES) {
        if (numEnemies < MAX_ENEMIES) {
          this.createEnemy();
        }
      }
      this.doPhysics(LOOP_TIME_INTERVAL / 1000.0);
      this.broadcastState();
      diff = LOOP_TIME_INTERVAL - ((new Date().getTime()) - startTime);
      if (diff < 0) {
        console.log("WARNING: Game loop computation too slow!");
        diff = 0;
      }
      return setTimeout(this.loop, diff);
    };

    return Game;

  })();

  module.exports = Game;

}).call(this);

//# sourceMappingURL=index.js.map
